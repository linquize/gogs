package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
)

func visit(dir string, ignore []*regexp.Regexp, w *bufio.Writer) {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		log.Fatal(err)
	}

	for _, f := range files {
		skip := false
		for _, re := range ignore {
			if re.MatchString(f.Name()) {
				skip = true
				break
			}
		}
		if skip {
			continue
		}

		if !f.IsDir() {
			fmt.Fprintln(w, "//go:embed \"" + dir + "/" + f.Name() + "\"")
			w.Flush()
		} else {
			visit(dir + "/" + f.Name(), ignore, w)
		}
	}
}

func main() {
	pkg := "main"
	flag.StringVar(&pkg, "pkg", pkg, "Package name to use in the generated code.")
	outfile := "embed.go"
	flag.StringVar(&outfile, "o", outfile, "Optional name of the output file to be generated.")
	varname := "assetFs"
	flag.StringVar(&varname, "var", varname, "Optional name of the variable to be generated.")
	ignore := make([]string, 0)
	flag.Var((*AppendSliceValue)(&ignore), "ignore", "Regex pattern to ignore")
	flag.Parse()

	patterns := make([]*regexp.Regexp, 0)
	for _, pattern := range ignore {
		patterns = append(patterns, regexp.MustCompile(pattern))
	}

	dir := "."
	if flag.NArg() > 0 {
		dir = flag.Arg(0)
	}

	f, err := os.Create(outfile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v", err)
		os.Exit(1)
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	fmt.Fprintln(w, "// Code generated by go-bindata. DO NOT EDIT.")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "package " + pkg)
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "import \"embed\"")
	fmt.Fprintln(w, "")
	visit(dir, patterns, w)
	fmt.Fprintln(w, "var " + varname + " embed.FS")
	w.Flush()
}

// borrowed from https://github.com/hashicorp/serf/blob/master/command/agent/flag_slice_value.go

// AppendSliceValue implements the flag.Value interface and allows multiple
// calls to the same variable to append a list.
type AppendSliceValue []string

func (s *AppendSliceValue) String() string {
	return strings.Join(*s, ",")
}

func (s *AppendSliceValue) Set(value string) error {
	if *s == nil {
		*s = make([]string, 0, 1)
	}

	*s = append(*s, value)
	return nil
}
